Directory structure:
└── umidjon-kh-wms/
    ├── README.md
    ├── test.py
    └── src/
        └── models/
            ├── __init__.py
            └── product/
                ├── __init__.py
                ├── constants.py
                ├── product.py
                ├── product__info_ru.md
                ├── product_info.md
                ├── validators_info.md
                ├── validators_info_ru.md
                ├── compositions/
                │   ├── __init__.py
                │   ├── classification.py
                │   ├── compositions_info.md
                │   ├── compositions_info_ru.md
                │   ├── dimensions.py
                │   ├── handling.py
                │   ├── storage_requires.py
                │   └── traceability.py
                └── enums/
                    ├── __init__.py
                    ├── enums.py
                    ├── enums_info.md
                    └── enums_info_ru.md

================================================
FILE: README.md
================================================
# WMS
Warehouse System Management



================================================
FILE: test.py
================================================
[Empty file]


================================================
FILE: src/models/__init__.py
================================================
from .product import BaseProduct, Dimensions, StorageRequirements, HandlingAttributes, Classification, Traceability

__all__ = ['BaseProduct', 'Dimensions', 'Traceability', 'Classification', 'HandlingAttributes', 'StorageRequirements']



================================================
FILE: src/models/product/__init__.py
================================================
from .product import BaseProduct
from .compositions import Dimensions, HandlingAttributes, StorageRequirements, Classification, Traceability

__all__ = ['BaseProduct', 'Dimensions', 'Traceability', 'Classification', 'HandlingAttributes', 'StorageRequirements']



================================================
FILE: src/models/product/constants.py
================================================
from pydantic import Field
from typing import Annotated, Optional

# Min Value Constants for sized type
HEAVY_MIN_KG = 50.0  # min weight for heavy size type
LIGHT_MAX_KG = 10.0  # max weight for light size type
OVERSIZED_MIN_CM = 200.0  # min size for oversized size type
SMALL_PARTS_MAX_CM = 30.0  # max size for small parts size type


# Validation Constants
SKU_VALID = Annotated[
    str, Field(pattern=r'^[A-Z0-9]{3,20}$', min_length=1, max_length=50, description='Unique SKU (Stock Keeping Unit)')
]
POSITIVE_F = Annotated[float, Field(ge=0)]
NAME_VALID = Annotated[str, Field(min_length=1, max_length=50, json_schema_extra={'strip_whitespace': True})]
DES_VALID = Annotated[Optional[str], Field(max_length=300)]



================================================
FILE: src/models/product/product.py
================================================
from pydantic import BaseModel, ConfigDict, Field, model_validator
from datetime import datetime
from typing import Optional
from .compositions import Dimensions, HandlingAttributes, Traceability, StorageRequirements, Classification
from .constants import (
    NAME_VALID,
    SKU_VALID,
    DES_VALID,
    HEAVY_MIN_KG,
    OVERSIZED_MIN_CM,
    LIGHT_MAX_KG,
    SMALL_PARTS_MAX_CM,
)
from .enums import (
    UnitOfMeasure,
    ProductPhysicalState,
    ProductStorageCondition,
    ProductSizeType,
    ProductTrackingType,
    ProductRoleType,
    PackagingType,
    ProductStatus,
)


# -------- Base Class Of Product --------
class BaseProduct(BaseModel):
    """
    Main core class that contains alls fields, Compostions
    and Cross Validators that need to work between compositions
    """

    # Pydantic model Configuration
    model_config = ConfigDict(
        slots=True,
        use_enum_values=True,  # Gives enum.value instaed of enum.key
        validate_assignment=True,  # validates in setting value
    )  # type: ignore

    # ----- main fields -----
    sku: SKU_VALID
    name: NAME_VALID
    unit_of_measure: UnitOfMeasure = Field(..., description='Base unit of measure (how product is counted)')
    physical_state: ProductPhysicalState = Field(..., description='Physical state of product')
    role_type: ProductRoleType = Field(..., description='Product role in production/logistic chain')
    status: ProductStatus = Field(..., description='Current lifecycle status')
    description: Optional[DES_VALID] = None

    # ---------- Compositions -------
    dimensions: Dimensions = Field(default_factory=lambda: Dimensions())
    handling: HandlingAttributes = Field(default_factory=lambda: HandlingAttributes())
    traceability: Traceability
    storage_requirements: StorageRequirements = Field(default_factory=lambda: StorageRequirements())
    classification: Classification = Field(default_factory=lambda: Classification())

    # ------ Technical fields (auto sets) -------
    created_at: datetime = Field(default_factory=datetime.now, description='Creation timestamp')
    updated_at: datetime = Field(default_factory=datetime.now, description='Las update timestamp')

    # -------- Cross Validators ---------
    @model_validator(mode='after')
    def validate_stgc_requirements(self) -> 'BaseProduct':
        """Validating Product Storage Condition types requirements"""
        # Validating for Perishable and Traceability products requirements
        if (
            self.storage_requirements.storage_condition
            in (ProductStorageCondition.PERISHABLE, ProductStorageCondition.MEDICINE)
            and self.traceability.tracking_type != ProductTrackingType.EXPIRY_TRACKED
        ):
            raise ValueError('Perishable and Medicine products must have tracking_type = EXPIRY_TRACKED')

        # Validation for Electronic product requirements
        elif (
            self.storage_requirements.storage_condition == ProductStorageCondition.ELECTRONICS
            and not self.handling.is_static_sensitive
        ):
            raise ValueError('Electronis products must be static sensitive')
        return self

    @model_validator(mode='after')
    def check_timesmaps(self) -> 'BaseProduct':
        """Validating timestamps of product"""
        if self.updated_at < self.created_at:
            raise ValueError('updated_at cant be earlier than creation_at')
        return self

    @model_validator(mode='after')
    def validate_units(self) -> 'BaseProduct':
        """Validating unit matchings"""
        # ------- Dict for all units type ---------
        weight_units = {UnitOfMeasure.KILOGRAM, UnitOfMeasure.GRAM}
        piece_units = {UnitOfMeasure.PIECE, UnitOfMeasure.BOX, UnitOfMeasure.PALLET, UnitOfMeasure.SET}
        # volume_units = {UnitOfMeasure.LITER, UnitOfMeasure.MILLILITER, UnitOfMeasure.CUBIC_METER}
        liquid_units = {UnitOfMeasure.LITER, UnitOfMeasure.MILLILITER}
        gas_units = {UnitOfMeasure.LITER, UnitOfMeasure.MILLILITER, UnitOfMeasure.CUBIC_METER}
        bulk_units = weight_units | {UnitOfMeasure.CUBIC_METER}

        # ------- Tracking type unit validation -------
        # Weight based
        if self.traceability.tracking_type == ProductTrackingType.WEIGHT_BASED:
            # Checking unit
            if self.unit_of_measure not in weight_units:
                raise ValueError('For tracking type Weight-Based products units must be in kg or gram')
        # Piece
        elif self.traceability.tracking_type == ProductTrackingType.PIECE:
            # Checking unit
            if self.unit_of_measure not in piece_units:
                raise ValueError('For tracking type Piece products units must be in pc, box, pallet or set')
        # Kit
        elif self.traceability.tracking_type == ProductTrackingType.KIT:
            # Checking unit
            if self.unit_of_measure not in (UnitOfMeasure.SET, UnitOfMeasure.PIECE):
                raise ValueError('For tracking type Kit products units must be in set or pc')

        # ---------- Physical state unit validation
        # Liquids
        if self.physical_state == ProductPhysicalState.LIQUID:
            # Checking unit
            if self.unit_of_measure not in liquid_units:
                raise ValueError('For products with physical state Liquid units must be in liter or mililiter')
            # Checking packaging type
            if self.storage_requirements.packaging_type == PackagingType.BOX:
                raise ValueError('Liquid products cannot be stored in boxes')
        # Gas
        elif self.physical_state == ProductPhysicalState.GAS:
            # Checking unit
            if self.unit_of_measure not in gas_units:
                raise ValueError(
                    'For products with physical state Gas units must be in liter, mililiter or cubic meter'
                )
            # Checking packaging type for gas
            if self.storage_requirements.packaging_type not in (PackagingType.CYLINDER, PackagingType.DRUM, None):
                raise ValueError('For products with physical state Gas packaging type must be in cylinder or drum')
            # Checking handling flags for gas
            if not self.handling.requires_ventilation:
                raise ValueError('Gas products should have requires_ventilation')
        # Bulk
        elif self.physical_state == ProductPhysicalState.BULK:
            # Checking unit
            if self.unit_of_measure not in bulk_units:
                raise ValueError('For products physical type Bulk units must be in weight or volume')
        return self

    @model_validator(mode='after')
    def validate_size_type(self) -> 'BaseProduct':
        """Validating size type requirements"""
        dims = self.dimensions
        # Heavy
        if self.classification.size_type == ProductSizeType.HEAVY:
            # Checking weight noen or not
            if dims.weight_kg is None:
                raise ValueError('For size_type Heavy products required weight_kg field')
            # Checking limit
            if dims.weight_kg < HEAVY_MIN_KG:
                raise ValueError(f'For size_type Heavy products min required weitgh is {HEAVY_MIN_KG} kg')

        # Over-sized
        elif self.classification.size_type == ProductSizeType.OVERSIZED:
            # Checkin contains dimension or not
            if dims.width_cm is None and dims.height_cm is None and dims.depth_cm is None:
                raise ValueError('For size_type Over-sized products min required 1 of 3 dimension(weight/height/depth)')
            # chekcing min cm of dimensions
            if not (
                dims.width_cm
                and dims.width_cm > OVERSIZED_MIN_CM
                or dims.height_cm
                and dims.height_cm > OVERSIZED_MIN_CM
                or dims.depth_cm
                and dims.depth_cm > OVERSIZED_MIN_CM
            ):
                raise ValueError(f'For size_type Over-sized products min required size is {OVERSIZED_MIN_CM} cm')

        # Light
        elif self.classification.size_type == ProductSizeType.LIGHT:
            # Checking weight is none or not
            if dims.weight_kg is None:
                raise ValueError('For sized_type Light products required weight_kg field')
            # Checking max weight for light products
            if dims.weight_kg > LIGHT_MAX_KG:
                raise ValueError(f'For size_type Light products max required weight is {LIGHT_MAX_KG} kg')

        # Small-parts
        elif self.classification.size_type == ProductSizeType.SMALL_PARTS:
            # Checkin contains dimension or not
            if dims.width_cm is None and dims.height_cm is None and dims.depth_cm is None:
                raise ValueError(
                    'For size_type Small-parts products min required 1 of 3 dimension(weight/height/depth)'
                )
            # chekcing min cm of dimensions
            if not (
                dims.width_cm
                and dims.width_cm < SMALL_PARTS_MAX_CM
                or dims.height_cm
                and dims.height_cm < SMALL_PARTS_MAX_CM
                or dims.depth_cm
                and dims.depth_cm < SMALL_PARTS_MAX_CM
            ):
                raise ValueError(f'For size_type Small-parts products max required size is {SMALL_PARTS_MAX_CM} cm')

        # For other size types if we need we add conditions for them
        # later not know caouse its not required
        return self

    @model_validator(mode='after')
    def validate_handlings(self) -> 'BaseProduct':
        """Validating handling matchings"""
        if not self.handling.is_stackable and self.classification.size_type in (
            ProductSizeType.HEAVY,
            ProductSizeType.OVERSIZED,
        ):
            raise ValueError('Heavy or oversized products cannot be stackable')
        return self

    @model_validator(mode='after')
    def validate_role(self) -> 'BaseProduct':
        """Validating role type matchings"""
        # For returned products must require quarantine
        if self.role_type == ProductRoleType.RETURNS and not self.handling.requires_quarantine:
            raise ValueError('Returned products must require quarantine')
        return self



================================================
FILE: src/models/product/product__info_ru.md
================================================
# Документация модели Product

Класс `BaseProduct` — основная модель, представляющая товар в системе управления складом. Она состоит из нескольких композиций, группирующих связанные атрибуты.

## Поля

| Поле | Тип | Описание | Обязательное |
|------|-----|----------|--------------|
| `sku` | `SKU_VALID` (аннотированная строка) | Уникальный идентификатор товара (SKU) | Да |
| `name` | `NAME_VALID` (аннотированная строка) | Наименование товара | Да |
| `unit_of_measure` | `UnitOfMeasure` (перечисление) | Базовая единица измерения (шт, кг, л и т.д.) | Да |
| `physical_state` | `ProductPhysicalState` (перечисление) | Физическое состояние (твёрдое, жидкое, газ, сыпучее) | Да |
| `role_type` | `ProductRoleType` (перечисление) | Роль в производственной/логистической цепочке | Да |
| `status` | `ProductStatus` (перечисление) | Текущий статус жизненного цикла | Да |
| `description` | `Optional[DES_VALID]` | Необязательное описание товара | Нет |

## Композиции

| Композиция | Описание |
|------------|----------|
| `dimensions` | Физические размеры и вес |
| `handling` | Флаги обращения (хрупкое, штабелируемое и т.д.) |
| `traceability` | Тип отслеживания, даты производства и срока годности |
| `storage_requirements` | Условия хранения (опасный груз, температура, упаковка) |
| `classification` | Тип размера, тип оборачиваемости, ABC‑категория |

Каждая композиция определена в своём модуле и содержит собственные валидации.

## Технические поля

| Поле | Тип | Описание |
|------|-----|----------|
| `created_at` | `datetime` | Временная метка создания (устанавливается автоматически) |
| `updated_at` | `datetime` | Временная метка последнего обновления (автоматически) |

## Кросс‑валидации

Класс `BaseProduct` включает несколько кросс‑валидаторов, обеспечивающих согласованность между различными композициями. Подробности см. в файле `Validators.md`.


================================================
FILE: src/models/product/product_info.md
================================================
# Product Model Documentation

The `BaseProduct` class is the core model representing a product in the Warehouse Management System. It consists of several compositions that group related attributes.

## Fields

| Field | Type | Description | Required |
|-------|------|-------------|----------|
| `sku` | `SKU_VALID` (annotated string) | Stock Keeping Unit – unique product identifier | Yes |
| `name` | `NAME_VALID` (annotated string) | Product name | Yes |
| `unit_of_measure` | `UnitOfMeasure` (enum) | Base unit of measure (piece, kg, liter, etc.) | Yes |
| `physical_state` | `ProductPhysicalState` (enum) | Physical state (solid, liquid, gas, bulk) | Yes |
| `role_type` | `ProductRoleType` (enum) | Role in production/logistic chain | Yes |
| `status` | `ProductStatus` (enum) | Current lifecycle status | Yes |
| `description` | `Optional[DES_VALID]` | Optional product description | No |

## Compositions

| Composition | Description |
|-------------|-------------|
| `dimensions` | Physical dimensions and weight |
| `handling` | Handling flags (fragile, stackable, etc.) |
| `traceability` | Tracking type, production and expiry dates |
| `storage_requirements` | Storage conditions (hazardous, temperature, packaging) |
| `classification` | Size type, moving type, ABC category |

Each composition is defined in its own module and contains its own validations.

## Technical Fields

| Field | Type | Description |
|-------|------|-------------|
| `created_at` | `datetime` | Timestamp of creation (auto-set) |
| `updated_at` | `datetime` | Timestamp of last update (auto-set) |

## Cross-Validations

The `BaseProduct` class includes several cross‑validators that ensure consistency between different compositions. See the `Validators.md` file for details.


================================================
FILE: src/models/product/validators_info.md
================================================
[Binary file]


================================================
FILE: src/models/product/validators_info_ru.md
================================================
# Validators Documentation

This document lists all validators in the `BaseProduct` model and its compositions. Validators ensure data consistency and enforce business rules.

## 1. Composition Validators

### 1.1. `Dimensions.calculato_vol`
- **Type:** `@model_validator`
- **Purpose:** Automatically calculates `volume_m3` from `width_cm`, `height_cm`, `depth_cm` if all three are provided and `volume_m3` is not set.

### 1.2. `HandlingAttributes.is_fragile_sctackable`
- **Type:** `@model_validator`
- **Purpose:** Ensures that if a product is fragile (`is_fragile = True`), it cannot be stackable (`is_stackable = False`).

### 1.3. `HandlingAttributes.recommendations_validator`
- **Type:** `@model_validator`
- **Purpose:** Prints a warning if an odor‑sensitive product does not have ventilation required (non‑blocking).

### 1.4. `Traceability.check_expiry_not_past`
- **Type:** `@field_validator('expiry_date')`
- **Purpose:** Raises `ValueError` if `expiry_date` is in the past.

### 1.5. `Traceability.check_dates_consistency`
- **Type:** `@model_validator`
- **Purpose:** Raises `ValueError` if both `production_date` and `expiry_date` are provided but `expiry_date` ≤ `production_date`.

### 1.6. `Traceability.check_expiry_tracking`
- **Type:** `@model_validator`
- **Purpose:** When `tracking_type = EXPIRY_TRACKED`, requires both `production_date` and `expiry_date`.

### 1.7. `StorageRequirements.check_hazard_consistency`
- **Type:** `@model_validator`
- **Purpose:** Ensures `hazard_class` is provided if and only if `storage_condition = HAZARDOUS`.

### 1.8. `StorageRequirements.check_temperature_required`
- **Type:** `@model_validator`
- **Purpose:** Requires `temperature_regime` when `storage_condition` is `PERISHABLE`, `TEMPERATURE_CONTROLLED` or `MEDICINE`.

### 1.9. `StorageRequirements.recommendations_validator`
- **Type:** `@model_validator`
- **Purpose:** Prints a warning if `storage_condition = ELECTRONICS` and `temperature_regime` is missing.

### 1.10. `Classification.validate_size_moving`
- **Type:** `@model_validator`
- **Purpose:** Prevents `FAST_MOVING` for `HEAVY` or `OVERSIZED` products.

### 1.11. `Classification.validate_category`
- **Type:** `@model_validator`
- **Purpose:** For `abc_category = A`, requires `moving_type` to be `FAST_MOVING` or `NORMAL_MOVING`.

---

## 2. Cross‑Validators in `BaseProduct`

All cross‑validators are `@model_validator(mode='after')` methods.

### 2.1. `validate_stgc_requirements`
- **Purpose:**
  - If `storage_condition` is `PERISHABLE` or `MEDICINE`, `tracking_type` must be `EXPIRY_TRACKED`.
  - If `storage_condition` is `ELECTRONICS`, `is_static_sensitive` must be `True`.

### 2.2. `check_timestamps`
- **Purpose:** Ensures `updated_at` is not earlier than `created_at`.

### 2.3. `validate_units`
- **Purpose:** Validates compatibility between `unit_of_measure`, `tracking_type`, `physical_state`, and `packaging_type`:
  - Weight‑based tracking → unit in `{kg, g}`.
  - Piece tracking → unit in `{pc, box, pallet, set}`.
  - Kit tracking → unit in `{set, pc}`.
  - Liquids → unit in `{l, ml}` and packaging not `box`.
  - Gases → unit in `{l, ml, m³}`, packaging must be `cylinder` or `drum`, and `requires_ventilation = True`.
  - Bulk → unit in weight or `m³`.

### 2.4. `validate_size_type`
- **Purpose:** Checks dimensional requirements based on `size_type`:
  - `HEAVY` → `weight_kg` provided and ≥ `HEAVY_MIN_KG`.
  - `OVERSIZED` → at least one dimension > `OVERSIZED_MIN_CM`.
  - `LIGHT` → `weight_kg` provided and ≤ `LIGHT_MAX_KG`.
  - `SMALL_PARTS` → at least one dimension < `SMALL_PARTS_MAX_CM`.

### 2.5. `validate_handlings`
- **Purpose:** If `size_type` is `HEAVY` or `OVERSIZED`, then `is_stackable` must be `False`.

### 2.6. `validate_role`
- **Purpose:** If `role_type = RETURNS`, then `requires_quarantine` must be `True`.


================================================
FILE: src/models/product/compositions/__init__.py
================================================
from .dimensions import Dimensions
from .handling import HandlingAttributes
from .traceability import Traceability
from .storage_requires import StorageRequirements
from .classification import Classification


__all__ = [
    'Dimensions',
    'HandlingAttributes',
    'Traceability',
    'StorageRequirements',
    'Classification',
]



================================================
FILE: src/models/product/compositions/classification.py
================================================
from pydantic import BaseModel, ConfigDict, Field, model_validator
from typing import Optional, Annotated
from ..enums import ProductSizeType, ProductMovingType, ABCCategory


class Classification(BaseModel):
    """
    Composition for product classification attributes.
    Includes size/weight category, turnover characteristic, and ABC category.
    """

    # Pydantic model Configuration
    model_config = ConfigDict(
        slots=True,
        use_enum_values=True,  # Gives enum.value instaed of enum.key
        validate_assignment=True,  # validates in setting value
    )  # type: ignore

    size_type: Annotated[
        Optional[ProductSizeType],
        Field(description='Size/weight category (oversized, heavy, light, small parts, etc.)'),
    ] = None

    moving_type: Annotated[
        Optional[ProductMovingType], Field(description='Turnover characteristic (fast, normal, slow moving, etc.)')
    ] = None

    abc_category: Annotated[
        Optional[ABCCategory], Field(description='ABC classification for inventory optimization (A, B, C, D)')
    ] = None

    # ----------- Validators --------
    @model_validator(mode='after')
    def validate_size_moving(self) -> 'Classification':
        """Validating size_type type matching with moving"""
        # For Heavy and Over_Sized must be not Fast Moving
        if (
            self.size_type in (ProductSizeType.HEAVY, ProductSizeType.OVERSIZED)
            and self.moving_type == ProductMovingType.FAST_MOVING
        ):
            raise ValueError('For Products with size_type Heavy and Over_sized moving_type cant be fast')
        return self

    @model_validator(mode='after')
    def validate_category(self) -> 'Classification':
        """Validating category type matching with moving"""
        if self.abc_category == ABCCategory.A and self.moving_type not in (
            ProductMovingType.FAST_MOVING,
            ProductMovingType.NORMAL_MOVING,
        ):
            raise ValueError('Products with ABC category A must have moving_type FAST_MOVING or NORMAL_MOVING')
        return self



================================================
FILE: src/models/product/compositions/compositions_info.md
================================================
# Compositions Documentation

## 1. Dimensions

File: `dimensions.py`

**Purpose:** Stores physical dimensions and weight of a product.

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `weight_kg` | `Optional[POSITIVE_F]` | Weight in kilograms |
| `width_cm` | `Optional[POSITIVE_F]` | Width in centimeters |
| `height_cm` | `Optional[POSITIVE_F]` | Height in centimeters |
| `depth_cm` | `Optional[POSITIVE_F]` | Depth in centimeters |
| `volume_m3` | `Optional[POSITIVE_F]` | Volume in cubic meters |

**Validations:**
- If all three dimensions (`width_cm`, `height_cm`, `depth_cm`) are provided and `volume_m3` is not, the volume is automatically calculated.

---

## 2. HandlingAttributes

File: `handling.py`

**Purpose:** Flags that describe special handling requirements.

**Fields:**

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `is_fragile` | `bool` | `False` | Fragile item |
| `is_stackable` | `bool` | `True` | Can be stacked |
| `is_odor_sensitive` | `bool` | `False` | Absorbs odors |
| `requires_ventilation` | `bool` | `False` | Needs ventilation |
| `requires_quarantine` | `bool` | `False` | Requires quarantine after return |
| `is_magnetic` | `bool` | `False` | Magnetic properties |
| `is_static_sensitive` | `bool` | `False` | Sensitive to static electricity |
| `irregular_shape` | `bool` | `False` | Irregular shape |

**Validations:**
- If `is_fragile` is `True`, then `is_stackable` must be `False`.
- If `is_odor_sensitive` is `True` and `requires_ventilation` is `False`, a warning is printed.

---

## 3. Traceability

File: `traceability.py`

**Purpose:** Tracks product through its lifecycle.

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `tracking_type` | `ProductTrackingType` | How the product is tracked |
| `production_date` | `Optional[date]` | Date of production |
| `expiry_date` | `Optional[date]` | Date of expiry |

**Validations:**
- `expiry_date` (if provided) cannot be in the past.
- If both dates are provided, `expiry_date` must be later than `production_date`.
- If `tracking_type = EXPIRY_TRACKED`, both `production_date` and `expiry_date` are required.

---

## 4. StorageRequirements

File: `storage_requires.py`

**Purpose:** Defines how the product should be stored.

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `storage_condition` | `Optional[ProductStorageCondition]` | General storage requirements |
| `hazard_class` | `Optional[HazardClass]` | Dangerous goods class (if hazardous) |
| `temperature_regime` | `Optional[TemperatureRegime]` | Required temperature regime |
| `packaging_type` | `Optional[PackagingType]` | Type of packaging used |

**Validations:**
- If `storage_condition = HAZARDOUS`, then `hazard_class` is required; conversely, if `hazard_class` is provided, `storage_condition` must be `HAZARDOUS`.
- If `storage_condition` is `PERISHABLE`, `TEMPERATURE_CONTROLLED` or `MEDICINE`, then `temperature_regime` is required.
- If `storage_condition = ELECTRONICS` and `temperature_regime` is missing, a warning is printed.

---

## 5. Classification

File: `classification.py`

**Purpose:** Classifies the product for storage optimization.

**Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `size_type` | `Optional[ProductSizeType]` | Size/weight category |
| `moving_type` | `Optional[ProductMovingType]` | Turnover characteristic |
| `abc_category` | `Optional[ABCCategory]` | ABC classification for inventory optimization |

**Validations:**
- If `size_type` is `HEAVY` or `OVERSIZED`, then `moving_type` cannot be `FAST_MOVING`.
- If `abc_category = A`, then `moving_type` must be either `FAST_MOVING` or `NORMAL_MOVING`.


================================================
FILE: src/models/product/compositions/compositions_info_ru.md
================================================
# Документация композиций

## 1. Dimensions

Файл: `dimensions.py`

**Назначение:** Хранит физические размеры и вес товара.

**Поля:**

| Поле | Тип | Описание |
|------|-----|----------|
| `weight_kg` | `Optional[POSITIVE_F]` | Вес в килограммах |
| `width_cm` | `Optional[POSITIVE_F]` | Ширина в сантиметрах |
| `height_cm` | `Optional[POSITIVE_F]` | Высота в сантиметрах |
| `depth_cm` | `Optional[POSITIVE_F]` | Глубина в сантиметрах |
| `volume_m3` | `Optional[POSITIVE_F]` | Объём в кубических метрах |

**Валидации:**
- Если указаны все три габарита (`width_cm`, `height_cm`, `depth_cm`), а `volume_m3` не задан, объём вычисляется автоматически.

---

## 2. HandlingAttributes

Файл: `handling.py`

**Назначение:** Флаги, описывающие особые требования к обращению.

**Поля:**

| Поле | Тип | По умолч. | Описание |
|------|-----|-----------|----------|
| `is_fragile` | `bool` | `False` | Хрупкий товар |
| `is_stackable` | `bool` | `True` | Можно штабелировать |
| `is_odor_sensitive` | `bool` | `False` | Впитывает запахи |
| `requires_ventilation` | `bool` | `False` | Требуется вентиляция |
| `requires_quarantine` | `bool` | `False` | Требуется карантин после возврата |
| `is_magnetic` | `bool` | `False` | Магнитные свойства |
| `is_static_sensitive` | `bool` | `False` | Чувствителен к статическому электричеству |
| `irregular_shape` | `bool` | `False` | Неправильная форма |

**Валидации:**
- Если `is_fragile = True`, то `is_stackable` должно быть `False`.
- Если `is_odor_sensitive = True`, а `requires_ventilation = False`, выводится предупреждение.

---

## 3. Traceability

Файл: `traceability.py`

**Назначение:** Отслеживает товар на протяжении жизненного цикла.

**Поля:**

| Поле | Тип | Описание |
|------|-----|----------|
| `tracking_type` | `ProductTrackingType` | Способ отслеживания |
| `production_date` | `Optional[date]` | Дата производства |
| `expiry_date` | `Optional[date]` | Срок годности |

**Валидации:**
- `expiry_date` (если указан) не может быть в прошлом.
- Если указаны обе даты, `expiry_date` должна быть позже `production_date`.
- Если `tracking_type = EXPIRY_TRACKED`, обязательны `production_date` и `expiry_date`.

---

## 4. StorageRequirements

Файл: `storage_requires.py`

**Назначение:** Определяет условия хранения товара.

**Поля:**

| Поле | Тип | Описание |
|------|-----|----------|
| `storage_condition` | `Optional[ProductStorageCondition]` | Общие требования к хранению |
| `hazard_class` | `Optional[HazardClass]` | Класс опасного груза (если опасный) |
| `temperature_regime` | `Optional[TemperatureRegime]` | Требуемый температурный режим |
| `packaging_type` | `Optional[PackagingType]` | Тип используемой упаковки |

**Валидации:**
- Если `storage_condition = HAZARDOUS`, то `hazard_class` обязателен; если указан `hazard_class`, то `storage_condition` должно быть `HAZARDOUS`.
- Если `storage_condition` равно `PERISHABLE`, `TEMPERATURE_CONTROLLED` или `MEDICINE`, то `temperature_regime` обязателен.
- Если `storage_condition = ELECTRONICS`, а `temperature_regime` не указан, выводится предупреждение.

---

## 5. Classification

Файл: `classification.py`

**Назначение:** Классифицирует товар для оптимизации размещения на складе.

**Поля:**

| Поле | Тип | Описание |
|------|-----|----------|
| `size_type` | `Optional[ProductSizeType]` | Категория размера/веса |
| `moving_type` | `Optional[ProductMovingType]` | Характеристика оборачиваемости |
| `abc_category` | `Optional[ABCCategory]` | ABC‑классификация для оптимизации запасов |

**Валидации:**
- Если `size_type` равен `HEAVY` или `OVERSIZED`, то `moving_type` не может быть `FAST_MOVING`.
- Если `abc_category = A`, то `moving_type` должен быть `FAST_MOVING` или `NORMAL_MOVING`.


================================================
FILE: src/models/product/compositions/dimensions.py
================================================
from pydantic import BaseModel, ConfigDict, Field, model_validator
from typing import Optional, Annotated
from ..constants import POSITIVE_F


class Dimensions(BaseModel):
    """
    Composition for Product Dimensions its Optional
    Cause one of the size type objects dont need
    all fields to be initialized its need to check
    dimensions or weight required for size type product
    """

    # Pydantic model Configuration
    model_config = ConfigDict(
        slots=True,
        validate_assignment=True,  # validates in setting value
    )  # type: ignore

    # Volume and Weights (optional)
    weight_kg: Annotated[Optional[POSITIVE_F], Field(description='Weight in kg')] = None
    width_cm: Annotated[Optional[POSITIVE_F], Field(description='Width in cm')] = None
    height_cm: Annotated[Optional[POSITIVE_F], Field(description='Height in cm')] = None
    depth_cm: Annotated[Optional[POSITIVE_F], Field(description='Depth in cm')] = None
    volume_m3: Annotated[Optional[POSITIVE_F], Field(description='Volume in cubic meters')] = None

    # ----------- Validators --------
    @model_validator(mode='after')
    def calculato_vol(self) -> 'Dimensions':
        """If all three dimensions are not None, volume calculates auto"""
        if self.volume_m3 is None and self.width_cm and self.height_cm and self.depth_cm:
            # Volume in m^3: = (cm * cm * cm) / 1_000_000
            self.volume_m3 = (self.width_cm * self.height_cm * self.depth_cm) / 1_000_000
        return self



================================================
FILE: src/models/product/compositions/handling.py
================================================
from pydantic import BaseModel, ConfigDict, Field, model_validator
from typing import Annotated


class HandlingAttributes(BaseModel):
    """
    Attributes of product that need to
    info about Specific Flags
    """

    # Pydantic model Configuration
    model_config = ConfigDict(
        slots=True,
        validate_assignment=True,  # validates in setting value
    )  # type: ignore

    is_fragile: Annotated[bool, Field(description='Fragile item')] = False
    is_stackable: Annotated[bool, Field(description='Can be stacked')] = True
    is_odor_sensitive: Annotated[bool, Field(description='Absorbs odors')] = False
    requires_ventilation: Annotated[bool, Field(description='Need ventilation')] = False
    requires_quarantine: Annotated[bool, Field(description='Requires quarantine after return')] = False
    is_magnetic: Annotated[bool, Field(description='Magnetic properties')] = False
    is_static_sensitive: Annotated[bool, Field(description='Sensitive to static electricity')] = False
    irregular_shape: Annotated[bool, Field(description='Irregular shape')] = False

    # ----------- Validators --------
    @model_validator(mode='after')
    def is_fragile_sctackable(self) -> 'HandlingAttributes':
        """
        If is_fragile is True: stackable must be False
        cause fragile products cant be stackable
        """
        if self.is_fragile and self.is_stackable:
            raise ValueError('Fragile product can\'t be stackable.')
        return self

    @model_validator(mode='after')
    def recommendations_validator(self) -> 'HandlingAttributes':
        """Recommendations for handling type products"""
        # For Odor sensitive products recommend ventilation
        if self.is_odor_sensitive and not self.requires_ventilation:
            print('Recomendation: For Odor sensitive products recommends ventailation True')
        return self



================================================
FILE: src/models/product/compositions/storage_requires.py
================================================
from pydantic import BaseModel, ConfigDict, Field, model_validator
from typing import Optional, Annotated
from ..enums import ProductStorageCondition, HazardClass, TemperatureRegime, PackagingType


class StorageRequirements(BaseModel):
    """
    Composition for product storage conditions.
    Includes storage type, hazard class, temperature regime, and packaging.
    """

    # Pydantic model Configuration
    model_config = ConfigDict(
        slots=True,
        use_enum_values=True,  # Gives enum.value instaed of enum.key
        validate_assignment=True,  # validates in setting value
    )  # type: ignore

    storage_condition: Annotated[
        Optional[ProductStorageCondition],
        Field(description='General storage requirements (perishable, hazardous, etc.)'),
    ] = None
    hazard_class: Annotated[Optional[HazardClass], Field(description='Dangerous goods class (if Hazardous)')] = None
    temperature_regime: Annotated[Optional[TemperatureRegime], Field(description='Required temperature regime')] = None
    packaging_type: Annotated[Optional[PackagingType], Field(description='Type of packaging used')] = None

    # ----------- Validators --------
    @model_validator(mode='after')
    def check_hazard_consistency(self) -> 'StorageRequirements':
        """If storage_condition is HAZARDOUS, hazard_class must be provided, and vice versa."""
        if self.storage_condition == ProductStorageCondition.HAZARDOUS and self.hazard_class is None:
            raise ValueError('hazard_class required for hazardous products')
        if self.hazard_class is not None and self.storage_condition != ProductStorageCondition.HAZARDOUS:
            raise ValueError('hazard_class only allowed for hazardous products')
        return self

    @model_validator(mode='after')
    def check_temperature_required(self) -> 'StorageRequirements':
        """If storage_condition requires temperature control, temperature_regime must be provided."""
        if (
            self.storage_condition
            in (
                ProductStorageCondition.PERISHABLE,
                ProductStorageCondition.TEMPERATURE_CONTROLLED,
                ProductStorageCondition.MEDICINE,
            )
            and self.temperature_regime is None
        ):
            raise ValueError('temperature_regime required for perishable or temperature-controlled products')
        return self

    @model_validator(mode='after')
    def recommendations_validator(self) -> 'StorageRequirements':
        """Recommendation for StorageRequirements"""
        # For Electronics products recommend tempertaure_regime
        if self.storage_condition == ProductStorageCondition.ELECTRONICS and not self.temperature_regime:
            print('Recommendation: For product type Electronics recommendts temperature_regime')
        return self



================================================
FILE: src/models/product/compositions/traceability.py
================================================
from pydantic import BaseModel, ConfigDict, Field, field_validator, model_validator
from typing import Optional, Annotated
from datetime import date
from ..enums import ProductTrackingType


class Traceability(BaseModel):
    """
    Composition for product traceability attributes
    Includes tracking type, production date, expiry date and related validations
    """

    # Pydantic model Configuration
    model_config = ConfigDict(
        slots=True,
        use_enum_values=True,  # Gives enum.value instaed of enum.key
        validate_assignment=True,  # validates in setting value
    )  # type: ignore

    # Tracking type
    tracking_type: ProductTrackingType = Field(..., description='How the product is tracked (piece, weitgh, etc...)')
    # For products that need production and expiry date
    production_date: Annotated[Optional[date], Field(description='Date of product production')] = None
    expiry_date: Annotated[Optional[date], Field(description='Date of product expiry')] = None

    # ----------- Validators --------
    @field_validator('expiry_date')
    @classmethod
    def check_expiry_not_past(cls, value: Optional[date]) -> Optional[date]:
        """Expiry date cannot be in the past (if provided)."""
        if value is not None and value < date.today():
            raise ValueError('expiry_date cannot be in the past')
        return value

    @model_validator(mode='after')
    def check_dates_consistency(self) -> 'Traceability':
        """If both dates provided, expiry must be after production."""
        if self.production_date and self.expiry_date:
            if self.expiry_date <= self.production_date:
                raise ValueError('expiry_date must be later than production_date')
        return self

    @model_validator(mode='after')
    def check_expiry_tracking(self) -> 'Traceability':
        """If tracking type is EXPIRY_TRACKED, both dates must be provided."""
        if self.tracking_type == ProductTrackingType.EXPIRY_TRACKED:
            if self.production_date is None:
                raise ValueError('production_date required for expiry tracked products')
            if self.expiry_date is None:
                raise ValueError('expiry_date required for expiry tracked products')
        return self



================================================
FILE: src/models/product/enums/__init__.py
================================================
from .enums import (
    ProductPhysicalState,
    ProductMovingType,
    ProductRoleType,
    ProductSizeType,
    ProductStatus,
    ProductStorageCondition,
    ProductTrackingType,
    PackagingType,
    HazardClass,
    ABCCategory,
    UnitOfMeasure,
    TemperatureRegime,
)

__all__ = [
    'ProductPhysicalState',
    'ProductMovingType',
    'ProductRoleType',
    'ProductSizeType',
    'ProductStatus',
    'ProductStorageCondition',
    'ProductTrackingType',
    'PackagingType',
    'HazardClass',
    'ABCCategory',
    'UnitOfMeasure',
    'TemperatureRegime',
]



================================================
FILE: src/models/product/enums/enums.py
================================================
from enum import Enum


# ---------- Unit of Measure ----------
class UnitOfMeasure(str, Enum):
    """
    This class identificates
    Base unit of measure for product
    """

    __slots__ = ()

    PIECE = 'pc'
    KILOGRAM = 'kg'
    GRAM = 'g'
    LITER = 'l'
    MILLILITER = 'ml'
    METER = 'm'
    CENTIMETER = 'cm'
    SQUARE_METER = 'm2'
    CUBIC_METER = 'm3'
    BOX = 'box'
    PALLET = 'pal'
    SET = 'set'


# ---------- Products Physical State Types ---------
class ProductPhysicalState(str, Enum):
    """
    This class identificates main state
    Product Physical State Type
    """

    __slots__ = ()

    SOLID = 'solid'
    BULK = 'bulk'
    LIQUID = 'liquid'
    GAS = 'gas'


# ---------- Products Storage Condition ---------
class ProductStorageCondition(str, Enum):
    """
    This class identificates
    Product Storage Condition
    """

    __slots__ = ()

    PERISHABLE = 'perishable'
    HAZARDOUS = 'hazardous'
    ELECTRONICS = 'electronics'
    MEDICINE = 'medicine'
    # Additional
    TEMPERATURE_CONTROLLED = 'temperature_controlled'
    VENTILATED = 'ventilated'
    ODOR_SENSITIVE = 'odor_sensitive'
    FOOD_SAFE = 'food_safe'


# ---------- Products Size Type ---------
class ProductSizeType(str, Enum):
    """
    This class identificates
    Product Size Type
    """

    __slots__ = ()

    OVERSIZED = 'oversized'
    HEAVY = 'heavy'
    MEDIUM = 'medium'
    SMALL_PARTS = 'small parts'
    # Additional
    BULKY = 'bulky'  # Need more space but not too heavy
    LIGHT = 'light'
    STANDARD = 'standard'


# ---------- Products Moving Type ---------
class ProductMovingType(str, Enum):
    """
    This class identificates
    Product Moving Type
    """

    __slots__ = ()

    FAST_MOVING = 'fast moving'
    NORMAL_MOVING = 'normal moving'
    SLOW_MOVING = 'slow moving'
    HIGH_VALUE = 'high value'
    # Additional
    SEASONAL = 'seasonal'
    PROMOTIONAL = 'promotional'


# ---------- Products Tracking Type ---------
class ProductTrackingType(str, Enum):
    """
    This class identificates
    Product Tracking Type
    """

    __slots__ = ()

    PIECE = 'piece'
    WEIGHT_BASED = 'weight_based'
    KIT = 'kit'
    # Additional
    SERIALIZED = 'serialized'  # track by serialized
    LOT_TRACKED = 'lot_tracked'  # track by lot
    EXPIRY_TRACKED = 'expiry_tracked'  # track expiry date


# ---------- Products Role in Production Type ---------
class ProductRoleType(str, Enum):
    """
    This class identificates
    Product Role in Production Type
    """

    __slots__ = ()

    RAW_MATERIAL = 'raw material'
    COMPONENTS = 'components'
    FINISHED_GOOD = 'finished good'
    RETURNS = 'returns'
    # Additional
    WORK_IN_PROGRESS = 'work in progress'
    PACKAGING = 'packaging'
    CONSUMABLE = 'consumable'
    TOOL = 'tool'
    SPARE_PART = 'spare part'
    SCRAP = 'scrap'
    SAMPLE = 'sample'


# ---------- Hazardous Class (if hazardous) ----------
class HazardClass(str, Enum):
    """
    This class identificates
    Hazard class according to international standards (e.g., ADR)
    """

    __slots__ = ()

    CLASS_1 = '1'  # Explosive
    CLASS_2 = '2'  # Gas
    CLASS_3 = '3'  # Flammable liquid
    CLASS_4 = '4'  # Flammable solid
    CLASS_5 = '5'  # Oxidizing
    CLASS_6 = '6'  # Toxic
    CLASS_7 = '7'  # Radioactive
    CLASS_8 = '8'  # Corrosive
    CLASS_9 = '9'  # Miscellaneous


# ---------- Temperature Regime ----------
class TemperatureRegime(str, Enum):
    """
    This class identificates
    Required temperature regime for storage
    """

    __slots__ = ()

    FROZEN = 'frozen'  # -18°C and below
    DEEP_FROZEN = 'deep_frozen'  # -30°C and below
    CHILLED = 'chilled'  # 0°C to +5°C
    COOL = 'cool'  # +10°C to +15°C
    AMBIENT = 'ambient'  # room temperature
    WARM = 'warm'  # +20°C to +25°C
    CONTROLLED = 'controlled'  # specific range defined separately


# ---------- ABC Classification (for inventory optimization) ----------
class ABCCategory(str, Enum):
    """
    This class identificates
    ABC analysis category based on value and turnover
    """

    __slots__ = ()

    A = 'A'  # high value, fast moving
    B = 'B'  # medium value/medium moving
    C = 'C'  # low value, slow moving
    D = 'D'  # obsolete, very slow


# ---------- Packaging Type ----------
class PackagingType(str, Enum):
    """
    This class identificates
    Type of packaging used for storage/shipping
    """

    __slots__ = ()

    BAG = 'bag'
    BOX = 'box'
    CRATE = 'crate'
    DRUM = 'drum'
    PALLET = 'pallet'
    IBC = 'ibc'  # intermediate bulk container
    TOTE = 'tote'
    CYLINDER = 'cylinder'
    CARDBOARD = 'cardboard'
    SHRINK_WRAP = 'shrink_wrap'
    NONE = 'none'  # unpackaged / loose


# ---------- Product Status (Lifecycle) ----------
class ProductStatus(str, Enum):
    """
    This class identificates
    Current lifecycle status of the product
    """

    __slots__ = ()

    ACTIVE = 'active'
    INACTIVE = 'inactive'
    DISCONTINUED = 'discontinued'
    COMING_SOON = 'coming_soon'
    PENDING_APPROVAL = 'pending_approval'
    UNDER_REVIEW = 'under_review'
    RETURNED = 'returned'
    DAMAGED = 'damaged'
    QUARANTINED = 'quarantined'



================================================
FILE: src/models/product/enums/enums_info.md
================================================
# WMS Enums Reference

This document provides a comprehensive reference for all enumeration classes used in the Warehouse Management System (WMS) data models. Each enum defines a set of constant values for specific attributes of products, helping to standardize data entry and enable consistent business logic.

---

## 1. `UnitOfMeasure`

Base units in which products are measured and tracked.

| Value | Description |
|-------|-------------|
| `PIECE` (`pc`) | Individual pieces (discrete count) |
| `KILOGRAM` (`kg`) | Kilograms |
| `GRAM` (`g`) | Grams |
| `LITER` (`l`) | Liters |
| `MILLILITER` (`ml`) | Milliliters |
| `METER` (`m`) | Meters (for roll/linear goods) |
| `CENTIMETER` (`cm`) | Centimeters |
| `SQUARE_METER` (`m2`) | Square meters |
| `CUBIC_METER` (`m3`) | Cubic meters (volume) |
| `BOX` (`box`) | Boxes (packaging unit) |
| `PALLET` (`pal`) | Pallets |
| `SET` (`set`) | Sets / kits |

---

## 2. `ProductPhysicalState`

Physical state of the product, influencing container type and handling methods.

| Value | Description |
|-------|-------------|
| `SOLID` | Solid goods (regular items, parts, furniture) |
| `BULK` | Bulk solids (sand, grain, granules) |
| `LIQUID` | Liquids (water, oil, chemicals) |
| `GAS` | Gases (propane, oxygen) |

---

## 3. `ProductStorageCondition`

General storage requirements for the product.

| Value | Description |
|-------|-------------|
| `PERISHABLE` | Perishable goods (require refrigeration/freezing) |
| `HAZARDOUS` | Hazardous materials (need special zones and safety measures) |
| `ELECTRONICS` | Electronics (sensitive to static, humidity) |
| `MEDICINE` | Medicines (strict temperature control, traceability) |
| `TEMPERATURE_CONTROLLED` | Requires specific temperature range |
| `VENTILATED` | Needs ventilation |
| `ODOR_SENSITIVE` | Absorbs odors – must not be stored near smelly items |
| `FOOD_SAFE` | Safe for contact with food products |

> **Note**: If the product is hazardous, detailed classification is provided by `HazardClass`.

---

## 4. `ProductSizeType`

Size/weight category, helping to choose appropriate storage locations.

| Value | Description |
|-------|-------------|
| `OVERSIZED` | Oversized (does not fit standard racks) |
| `HEAVY` | Heavy (requires reinforced shelving or floor storage) |
| `MEDIUM` | Medium-sized (standard racks) |
| `SMALL_PARTS` | Small parts (stored in bins, small boxes) |
| `BULKY` | Bulky but lightweight |
| `LIGHT` | Lightweight (can be stored on upper shelves) |
| `STANDARD` | Standard dimensions (default) |

---

## 5. `ProductMovingType`

Turnover characteristic, influencing storage placement (fast movers near shipping).

| Value | Description |
|-------|-------------|
| `FAST_MOVING` | High turnover (frequently shipped) |
| `NORMAL_MOVING` | Medium turnover |
| `SLOW_MOVING` | Low turnover |
| `HIGH_VALUE` | High-value items (may be stored in secured area) |
| `SEASONAL` | Seasonal goods |
| `PROMOTIONAL` | Promotional items (temporarily high turnover) |

---

## 6. `ProductTrackingType`

Method used to track inventory.

| Value | Description |
|-------|-------------|
| `PIECE` | Piece-level tracking |
| `WEIGHT_BASED` | Weight-based tracking |
| `KIT` | Kit (bundle of items) |
| `SERIALIZED` | Serial number tracking |
| `LOT_TRACKED` | Lot/batch tracking |
| `EXPIRY_TRACKED` | Expiry date tracking |

---

## 7. `ProductRoleType`

Role of the product in the production or logistics chain.

| Value | Description |
|-------|-------------|
| `RAW_MATERIAL` | Raw material for production |
| `COMPONENTS` | Components / subassemblies |
| `FINISHED_GOOD` | Finished product ready for sale |
| `RETURNS` | Returned items (awaiting disposition) |
| `WORK_IN_PROGRESS` | Work in progress (semi-finished) |
| `PACKAGING` | Packaging materials |
| `CONSUMABLE` | Consumable supplies |
| `TOOL` | Tools / equipment |
| `SPARE_PART` | Spare parts |
| `SCRAP` | Scrap / waste |
| `SAMPLE` | Samples (not for sale) |

---

## 8. `HazardClass`

International hazard class for dangerous goods (based on ADR/IMDG classifications).

| Value | Description |
|-------|-------------|
| `CLASS_1` | Explosives |
| `CLASS_2` | Gases |
| `CLASS_3` | Flammable liquids |
| `CLASS_4` | Flammable solids |
| `CLASS_5` | Oxidizing substances and organic peroxides |
| `CLASS_6` | Toxic and infectious substances |
| `CLASS_7` | Radioactive material |
| `CLASS_8` | Corrosive substances |
| `CLASS_9` | Miscellaneous dangerous substances |

---

## 9. `TemperatureRegime`

Generalized temperature requirements for storage.

| Value | Description |
|-------|-------------|
| `FROZEN` | Frozen (-18°C and below) |
| `DEEP_FROZEN` | Deep frozen (-30°C and below) |
| `CHILLED` | Chilled (0°C to +5°C) |
| `COOL` | Cool (+10°C to +15°C) |
| `AMBIENT` | Ambient room temperature |
| `WARM` | Warm (+20°C to +25°C) |
| `CONTROLLED` | Specific controlled range (defined separately) |

---

## 10. `ABCCategory`

ABC classification for inventory optimization (value and turnover).

| Value | Description |
|-------|-------------|
| `A` | High value / fast moving |
| `B` | Medium value / medium moving |
| `C` | Low value / slow moving |
| `D` | Obsolete / very slow moving |

---

## 11. `HandlingAttribute`

Special handling attributes that can be combined (usually implemented as separate boolean fields in the model, listed here for reference).

| Value | Description |
|-------|-------------|
| `FRAGILE` | Fragile – requires careful handling |
| `STACKABLE` | Can be stacked |
| `ODOR_SENSITIVE` | Absorbs odors |
| `REQUIRES_VENTILATION` | Needs ventilation |
| `REQUIRES_QUARANTINE` | Requires quarantine (e.g., after returns) |
| `MAGNETIC` | Magnetic properties |
| `STATIC_SENSITIVE` | Sensitive to static electricity |
| `HEAVY` | Heavy (if not covered by `ProductSizeType`) |
| `LARGE` | Large |
| `IRREGULAR_SHAPE` | Irregular shape |

---

## 12. `PackagingType`

Type of packaging used for storage or shipping.

| Value | Description |
|-------|-------------|
| `BAG` | Bag |
| `BOX` | Box |
| `CRATE` | Crate (wooden/plastic) |
| `DRUM` | Drum |
| `PALLET` | Pallet |
| `IBC` | Intermediate Bulk Container |
| `TOTE` | Tote / bin with lid |
| `CYLINDER` | Cylinder (for gases) |
| `CARDBOARD` | Cardboard packaging |
| `SHRINK_WRAP` | Shrink wrap / stretch film |
| `NONE` | No packaging / loose |

---

## 13. `ProductStatus`

Lifecycle status of the product in the catalog.

| Value | Description |
|-------|-------------|
| `ACTIVE` | Active, available for operations |
| `INACTIVE` | Inactive, temporarily not used |
| `DISCONTINUED` | Discontinued |
| `COMING_SOON` | Coming soon |
| `PENDING_APPROVAL` | Pending approval |
| `UNDER_REVIEW` | Under review |
| `RETURNED` | Returned (awaiting decision) |
| `DAMAGED` | Damaged |
| `QUARANTINED` | In quarantine |

---

*This reference is intended for developers and integrators working with the WMS data models.*


================================================
FILE: src/models/product/enums/enums_info_ru.md
================================================
# Справочник перечислений WMS

В этом документе представлен подробный справочник всех классов перечислений (enums), используемых в моделях данных системы управления складом (WMS). Каждое перечисление определяет набор констант для конкретных атрибутов продуктов, что помогает стандартизировать ввод данных и обеспечить согласованную бизнес-логику.

---

## 1. `UnitOfMeasure`

Базовые единицы измерения, в которых учитываются и отслеживаются продукты.

| Значение | Описание |
|----------|----------|
| `PIECE` (`pc`) | Отдельные штуки (дискретный счёт) |
| `KILOGRAM` (`kg`) | Килограммы |
| `GRAM` (`g`) | Граммы |
| `LITER` (`l`) | Литры |
| `MILLILITER` (`ml`) | Миллилитры |
| `METER` (`m`) | Метры (для рулонных/погонажных товаров) |
| `CENTIMETER` (`cm`) | Сантиметры |
| `SQUARE_METER` (`m²`) | Квадратные метры |
| `CUBIC_METER` (`m³`) | Кубические метры (объём) |
| `BOX` (`box`) | Коробки (упаковочная единица) |
| `PALLET` (`pal`) | Паллеты |
| `SET` (`set`) | Наборы / комплекты |

---

## 2. `ProductPhysicalState`

Физическое состояние продукта, влияющее на выбор типа контейнера и методы обработки.

| Значение | Описание |
|----------|----------|
| `SOLID` | Твёрдые товары (обычные предметы, запчасти, мебель) |
| `BULK` | Насыпные твёрдые (песок, зерно, гранулы) |
| `LIQUID` | Жидкости (вода, масло, химикаты) |
| `GAS` | Газы (пропан, кислород) |

---

## 3. `ProductStorageCondition`

Общие требования к хранению продукта.

| Значение | Описание |
|----------|----------|
| `PERISHABLE` | Скоропортящиеся товары (требуют холодильника/морозильника) |
| `HAZARDOUS` | Опасные материалы (нуждаются в специальных зонах и мерах безопасности) |
| `ELECTRONICS` | Электроника (чувствительна к статике, влажности) |
| `MEDICINE` | Лекарства (строгий температурный режим, прослеживаемость) |
| `TEMPERATURE_CONTROLLED` | Требуют определённого температурного диапазона |
| `VENTILATED` | Нуждаются в вентиляции |
| `ODOR_SENSITIVE` | Впитывают запахи – нельзя хранить рядом с пахучими товарами |
| `FOOD_SAFE` | Безопасны для контакта с пищевыми продуктами |

> **Примечание**: Если продукт опасен, подробная классификация задаётся через `HazardClass`.

---

## 4. `ProductSizeType`

Категория размера/веса, помогающая выбрать подходящее место хранения.

| Значение | Описание |
|----------|----------|
| `OVERSIZED` | Крупногабаритные (не помещаются в стандартные стеллажи) |
| `HEAVY` | Тяжёлые (требуют усиленных стеллажей или хранения на полу) |
| `MEDIUM` | Среднего размера (стандартные стеллажи) |
| `SMALL_PARTS` | Мелкие детали (хранятся в контейнерах, небольших коробках) |
| `BULKY` | Громоздкие, но лёгкие |
| `LIGHT` | Лёгкие (можно хранить на верхних полках) |
| `STANDARD` | Стандартные габариты (по умолчанию) |

---

## 5. `ProductMovingType`

Характеристика оборачиваемости, влияющая на размещение (быстрооборачиваемые товары ближе к отгрузке).

| Значение | Описание |
|----------|----------|
| `FAST_MOVING` | Высокая оборачиваемость (часто отгружаются) |
| `NORMAL_MOVING` | Средняя оборачиваемость |
| `SLOW_MOVING` | Низкая оборачиваемость |
| `HIGH_VALUE` | Дорогостоящие товары (могут храниться в охраняемой зоне) |
| `SEASONAL` | Сезонные товары |
| `PROMOTIONAL` | Акционные товары (временно высокая оборачиваемость) |

---

## 6. `ProductTrackingType`

Способ отслеживания запасов.

| Значение | Описание |
|----------|----------|
| `PIECE` | Поштучное отслеживание |
| `WEIGHT_BASED` | Отслеживание по весу |
| `KIT` | Комплект (набор предметов) |
| `SERIALIZED` | Отслеживание по серийным номерам |
| `LOT_TRACKED` | Отслеживание по партиям |
| `EXPIRY_TRACKED` | Отслеживание по срокам годности |

---

## 7. `ProductRoleType`

Роль продукта в производственной или логистической цепочке.

| Значение | Описание |
|----------|----------|
| `RAW_MATERIAL` | Сырьё для производства |
| `COMPONENTS` | Комплектующие / узлы |
| `FINISHED_GOOD` | Готовая продукция, готовая к продаже |
| `RETURNS` | Возвращённые товары (ожидающие решения) |
| `WORK_IN_PROGRESS` | Незавершённое производство (полуфабрикаты) |
| `PACKAGING` | Упаковочные материалы |
| `CONSUMABLE` | Расходные материалы |
| `TOOL` | Инструменты / оборудование |
| `SPARE_PART` | Запасные части |
| `SCRAP` | Брак / отходы |
| `SAMPLE` | Образцы (не для продажи) |

---

## 8. `HazardClass`

Международный класс опасности для опасных грузов (на основе классификаций ADR/IMDG).

| Значение | Описание |
|----------|----------|
| `CLASS_1` | Взрывчатые вещества |
| `CLASS_2` | Газы |
| `CLASS_3` | Легковоспламеняющиеся жидкости |
| `CLASS_4` | Легковоспламеняющиеся твёрдые вещества |
| `CLASS_5` | Окисляющие вещества и органические пероксиды |
| `CLASS_6` | Токсичные и инфекционные вещества |
| `CLASS_7` | Радиоактивные материалы |
| `CLASS_8` | Коррозионные вещества |
| `CLASS_9` | Прочие опасные вещества и изделия |

---

## 9. `TemperatureRegime`

Обобщённые температурные требования к хранению.

| Значение | Описание |
|----------|----------|
| `FROZEN` | Замороженные (-18°C и ниже) |
| `DEEP_FROZEN` | Глубокой заморозки (-30°C и ниже) |
| `CHILLED` | Охлаждённые (от 0°C до +5°C) |
| `COOL` | Прохладные (от +10°C до +15°C) |
| `AMBIENT` | Комнатная температура |
| `WARM` | Тёплые (от +20°C до +25°C) |
| `CONTROLLED` | Контролируемый диапазон (задаётся отдельно) |

---

## 10. `ABCCategory`

ABC-классификация для оптимизации запасов (по стоимости и оборачиваемости).

| Значение | Описание |
|----------|----------|
| `A` | Высокая стоимость / быстрая оборачиваемость |
| `B` | Средняя стоимость / средняя оборачиваемость |
| `C` | Низкая стоимость / медленная оборачиваемость |
| `D` | Устаревшие / очень медленная оборачиваемость |

---

## 11. `HandlingAttribute`

Специальные атрибуты обработки, которые можно комбинировать (обычно реализуются как отдельные булевы поля в модели; здесь приведены для справки).

| Значение | Описание |
|----------|----------|
| `FRAGILE` | Хрупкое – требует осторожного обращения |
| `STACKABLE` | Можно штабелировать |
| `ODOR_SENSITIVE` | Впитывает запахи |
| `REQUIRES_VENTILATION` | Требует вентиляции |
| `REQUIRES_QUARANTINE` | Требует карантина (например, после возвратов) |
| `MAGNETIC` | Обладает магнитными свойствами |
| `STATIC_SENSITIVE` | Чувствителен к статическому электричеству |
| `HEAVY` | Тяжёлый (если не охвачено `ProductSizeType`) |
| `LARGE` | Крупногабаритный |
| `IRREGULAR_SHAPE` | Неправильная форма |

---

## 12. `PackagingType`

Тип упаковки, используемой для хранения или отгрузки.

| Значение | Описание |
|----------|----------|
| `BAG` | Мешок |
| `BOX` | Коробка |
| `CRATE` | Ящик (деревянный/пластиковый) |
| `DRUM` | Барабан / бочка |
| `PALLET` | Паллет |
| `IBC` | Промежуточный контейнер для сыпучих/жидких грузов |
| `TOTE` | Контейнер / ящик с крышкой |
| `CYLINDER` | Баллон (для газов) |
| `CARDBOARD` | Картонная упаковка |
| `SHRINK_WRAP` | Термоусадочная плёнка / стретч-плёнка |
| `NONE` | Без упаковки / россыпью |

---

## 13. `ProductStatus`

Статус жизненного цикла продукта в каталоге.

| Значение | Описание |
|----------|----------|
| `ACTIVE` | Активен, доступен для операций |
| `INACTIVE` | Неактивен, временно не используется |
| `DISCONTINUED` | Снят с производства |
| `COMING_SOON` | Скоро появится |
| `PENDING_APPROVAL` | Ожидает утверждения |
| `UNDER_REVIEW` | На рассмотрении |
| `RETURNED` | Возвращён (ожидает решения) |
| `DAMAGED` | Повреждён |
| `QUARANTINED` | В карантине |

---

*Данный справочник предназначен для разработчиков и интеграторов, работающих с моделями данных WMS.*

